## Pulse Delivery Roadmap

### Phase 0 – Foundations
- [x] Initialize Flutter project structure and configure Firebase project (Firestore, Storage, Authentication). (Test: Run `flutter run` on iOS and Android simulators to confirm the project boots with Firebase configs and no missing asset errors.)
- [x] Enable anonymous auth for quick prototype sign-in and set default security rules to deny writes by unauthenticated users. (Test: Sign out/in on a clean install and attempt a Firestore write from the client to verify rules block unauthenticated access.)
- [x] Scaffold core navigation: bottom tabs (Home, Account, Discover placeholder). (Test: Navigate across all three tabs after hot restart to ensure state and theme persist without crashes.)
- [x] Implement ThemeProvider, app theme switch, and persist preference locally. (Test: Toggle dark mode, kill the app, relaunch, and ensure the previous theme returns while navigation/auth still behave.)
- [x] Wire Firebase initialization with `firebase_core` and confirm anonymous login flow. (Test: Observe app logs for successful anonymous UID issuance on cold start and confirm `AuthGate` routes to the main tabs.)
- [x] Define core terminology (Pulse) and update copywriting guidelines so UI messaging stays consistent. (Test: Run `rg "check-in"` over lib/docs to verify only legacy references remain and review `copywriting.txt` for coverage.)

### Phase 1 – Core Pulse Experience
- [x] Design Firestore collections (`users`, `venues`, `pulses`) aligned with firebase.txt spec. (Test: Execute unit tests instantiating the new model classes and ensure Firestore converters serialize/deserialize sample payloads correctly.)
- [x] Build location permission request & geolocation service (using `geolocator` or similar). (Test: Launch on a fresh simulator, grant/deny permissions, and confirm the location state updates without breaking anonymous auth or theme persistence.)
- [x] Implement venue search + nearby list using sample data; integrate Firestore geohash queries later. (Test: Seed mock venues, search for a keyword, and verify results refresh while navigation tabs and location service keep functioning.)
- [x] Wire up MapLibre GL with OpenStreetMap tiles for the discovery map and test marker rendering. (Test: Render the Discover map after location permission is granted and ensure MapLibre tiles plus markers appear with no dropped frames.)
- [x] Validate tile usage limits and configure style/theme files for MapLibre to match Pulse branding. (Test: Inspect MapLibre network calls during a 10-minute session to confirm tile limits aren't exceeded and styles match light/dark theme toggles.)
- [x] Integrate Foursquare Places API (free tier) for venue metadata during prototyping. (Test: Call the API via staging key, cache the response, and compare venue details with Firestore docs to ensure consistency and rate-limit compliance.)
- [x] Migrate from Foursquare to Google Places API for better free tier and data quality. (Test: Verify Google Places API integration works with real-time search toggle and proper API key management.)
- [x] Implement real-time search toggle in Discover screen to control API usage and costs. (Test: Toggle live search on/off, verify typing works in both modes and API calls only trigger when live mode is active.)
- [x] Stub abstraction layer so alternate POI providers can be swapped without core refactor. (Test: Swap the provider implementation in tests to a mock HERE client and verify the UI still lists venues without code changes elsewhere.)
- [x] Implement core Firestore collections (`users`, `venues`, `pulses`) with proper data models. (Test: Create sample documents in each collection via admin SDK and verify data structure matches firebase.txt spec with proper field types.)
- [x] Build User Profile system with displayName, avatar upload, and privacy settings. (Test: Create user profile, upload avatar to Storage, update privacy settings, and verify Firestore security rules enforce ownership.)
- [x] Implement Venue creation and caching system for Foursquare data in Firestore. (Test: Search venues via POI providers, cache results in `venues` collection, and verify subsequent searches use cached data to reduce API calls.)
- [x] Add Firestore security rules for all collections according to firebase.txt privacy model. (Test: Run Firebase emulator with security rule tests to ensure proper access control for users, venues, pulses, and friendships collections.)
- [x] Create basic User authentication flow (email/password) with profile creation. (Test: Register new user, create profile document in Firestore, and verify authentication state persists across app restarts.)
- [ ] Create Pulse composer (select venue, mood, caption, optional photo upload to Storage). (Test: Submit a Pulse with photo on both Wi-Fi and offline to ensure drafts handle failures and the mirrored user collection writes correctly.)
- [ ] Add lightweight privacy controls to the composer (public / friends / private) with client validation. (Test: Create Pulses under each visibility level and confirm the feed respects the filter while Firestore rules block unauthorized readers.)
- [ ] Write Cloud Function or serverless callable to mirror Pulses into `users/{userId}/pulses` and update counters. (Test: Trigger the function locally with emulators and verify both global and user collections receive the new document with updated stats.)
- [ ] Enforce security rules for anonymous users (read-only public venues, own Pulses only). (Test: Run Firestore emulator tests that attempt cross-user writes to ensure rules reject them while allowing public reads.)
- [ ] Basic activity feed showing recent public Pulses; apply visibility filtering client-side for now. (Test: Log in with two accounts, post Pulses under different visibilities, and confirm the feed only shows public entries to anonymous users.)

### Phase 2 – Social Growth Loop
- [ ] Implement `friendships` collection with composite keys for friend relationships. (Test: Create friendship documents with proper pairId format, test pending/accepted/blocked states, and verify security rules allow both participants to read.)
- [ ] Build Friends system UI (send requests, accept/decline, block users, friends list). (Test: Complete full friendship flow between two users and verify both users see updated friend status in real-time.)
- [ ] Create `notifications` subcollection under users for in-app notifications. (Test: Generate friend request notifications, mark as read, and verify proper pagination and real-time updates.)
- [ ] Implement Pulse visibility system (public/friends/private) with Firestore rule enforcement. (Test: Create Pulses with different visibility levels and verify friends see friend-only content while strangers cannot.)
- [ ] Migrate authentication from anonymous to email/password; retain anonymous sessions with link flow. (Test: Link an existing anonymous session to email, sign out/in, and confirm the user retains their Pulses and tokens.)
- [ ] Update security rules to require verified auth for write operations; restrict anonymous users to read-only mode. (Test: Run emulator rule tests ensuring anonymous users receive PERMISSION_DENIED on writes while linked accounts succeed.)
- [ ] Build profile screen editing (displayName, avatar upload) with Storage rules enforcement. (Test: Upload a new avatar, reload the app, and confirm Storage metadata enforces ownership and the UI shows the updated image.)
- [ ] Add user stats tracking (pulseCount, friendCount) updated via Cloud Functions. (Test: Create Pulses and friend relationships, verify stats automatically update in user documents without client-side writes.)
- [ ] Launch collaborative planning boards (shared checklists, polls) tied to venues or time slots. (Test: Have multiple friends edit the same board simultaneously and ensure optimistic updates sync without conflicts.)
- [ ] Highlight meaningful contributions (tips, photos, accessibility info) within venue detail views and feeds. (Test: Submit diverse tips and verify only high-signal contributions surface after feed refresh while navigation remains responsive.)
- [ ] Introduce push notification registration via FCM token storage and targeted friend activity notifications. (Test: Register two devices, trigger a friend Pulse, and confirm only opted-in friends receive the push with correct deep link.)
- [ ] Add simple in-app notifications (Firestore `notifications` collection) for friend requests, accepted invites, and collaborative updates. (Test: Simulate friend invites and confirm notification badges update, clearing properly after viewing.)
- [ ] Prototype creator/venue tooling (featured guides, partner badges) to seed premium content. (Test: Create a partner guide via admin tools and ensure it appears in Discover without exposing controls to regular users.)

### Phase 3 – Intelligent & Adaptive Experience
- [ ] Implement venue `tips` and `snapshots` subcollections for user-generated content. (Test: Submit venue tips, verify subcollection structure, and test daily snapshot aggregation via Cloud Functions.)
- [ ] Add venue rating system with duplicate prevention and real-time average calculation. (Test: Submit multiple ratings from same user, verify only latest counts, and check ratingSummary updates correctly.)
- [ ] Create `activities` collection for user activity feeds and notification fan-out. (Test: Generate various activity types, verify proper fan-out to followers, and test activity feed pagination.)
- [ ] Implement composite Firestore indexes for efficient queries (venue timeline, user pulses, activity feeds). (Test: Query large datasets and verify index usage in Firebase console, ensure sub-second response times.)
- [ ] Add Firebase Storage integration for pulse media with proper security rules. (Test: Upload pulse photos, verify Storage paths follow security model, and test automatic thumbnail generation.)
- [ ] Integrate live Firestore venue data with geospatial indexing (GeoFireX or custom geohash queries). (Test: Run geospatial queries at varying radii and verify results stay within expected bounds and update after moving location.)
- [ ] Upgrade Foursquare usage to production plan or cache data via Cloud Functions to stay within limits. (Test: Replay a day's worth of venue lookups and confirm cached responses reduce API calls under quota.)
- [ ] Launch badge system: define `badges` documents and Cloud Functions for progress tracking. (Test: Award a badge via automated function and assert the user sees it in their profile while duplicates are prevented.)
- [ ] Personalize discovery feeds using context (time of day, weather, past behavior) and privacy preferences. (Test: Switch contexts (morning/night) on test accounts and ensure recommended Pulses change while respecting privacy flags.)
- [ ] Measure success beyond Pulse volume—track recommendation follow-through metrics via analytics pipeline. (Test: Review the analytics dashboard after simulated sessions to confirm recommendation_click events correlate with venue visits.)
- [ ] Enhance activity feed with badges, friend joins, and trending venues; optimize queries via composite indexes. (Test: Run load tests fetching feeds for 1k users and verify indexes prevent Firestore query failures.)
- [ ] Implement moderation/reporting callable functions and admin tooling (custom claims). (Test: Invoke the callable with and without admin claims to ensure only moderators can change Pulse visibility.)
- [ ] Switch default privacy to friends-only and provide granular privacy settings UI. (Test: Create new accounts and confirm their default Pulse visibility is friends-only while existing users retain previous choices.)
- [ ] Prototype an AI assistant that suggests meetups or itineraries using current location + friend availability. (Test: Feed mock schedules into the assistant and ensure suggested itineraries respect location consent and friend statuses.)
- [ ] Optimize Storage usage: generate thumbnails via Cloud Functions and lazy load media. (Test: Upload large media files and verify thumbnails appear while original downloads defer until tapped, reducing bandwidth.)

### Phase 4 – Scaling & Polish
- [ ] Implement Cloud Functions for automated Pulse processing (user collection mirroring, stats updates). (Test: Deploy functions to Firebase, trigger Pulse creation, and verify both global and user collections update automatically.)
- [ ] Create Cloud Functions for friendship status changes and notification delivery. (Test: Send friend request, verify function triggers create proper notifications for both users with correct payload.)
- [ ] Add scheduled Cloud Functions for trending venue calculations and data cleanup. (Test: Run scheduled function in emulator, verify trending scores update based on recent activity, and test TTL cleanup of old data.)
- [ ] Implement callable Cloud Functions for admin actions (moderation, venue claims, badge awards). (Test: Call admin functions with/without proper permissions, verify custom claims enforcement and audit logging.)
- [ ] Introduce email verification and optional OAuth providers (Apple/Google) for better retention. (Test: Register via Google and Email, verify addresses, and ensure existing anonymous Pulses remain linked after upgrade.)
- [ ] Build group threads and direct messaging using `messages` collection and presence indicators. (Test: Simulate three-user chats and confirm presence indicators update in real time without leaking data to outsiders.)
- [ ] Configure scheduled Cloud Functions for trending venue computations and stale activity cleanup (Firestore TTL). (Test: Run the scheduler in emulator mode to ensure old Pulses expire and trending scores update without failures.)
- [ ] Instrument analytics (Firebase Analytics/BigQuery) for engagement and growth dashboards. (Test: Export sample analytics events to BigQuery and verify dashboards refresh with accurate Pulse engagement metrics.)
- [ ] Load-test Firestore queries and refine indexes; review costs with budget alerts. (Test: Execute k6 or Firestore load tests exceeding baseline traffic and monitor GCP budget alerts firing correctly.)
- [ ] Harden security rules with simulator tests and add regression test suite in CI. (Test: Run `firebase emulators:exec` in CI and confirm all rule tests pass before allowing deployments.)
- [ ] Prepare App Store & Play Store deployment assets, privacy policy, and crash reporting (Crashlytics). (Test: Build release candidates, upload to TestFlight/Play Console, and verify Crashlytics captures test crashes without missing metadata.)
- [ ] Establish business/creator onboarding workflows and partnerships programs. (Test: Walk through the onboarding form end-to-end with a pilot partner and confirm approvals unlock creator-only tooling.)
