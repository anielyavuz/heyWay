## Pulse Delivery Roadmap

### Phase 0 – Foundations
- [x] Initialize Flutter project structure and configure Firebase project (Firestore, Storage, Authentication). (Test: Run `flutter run` on iOS and Android simulators to confirm the project boots with Firebase configs and no missing asset errors.)
- [x] Enable anonymous auth for quick prototype sign-in and set default security rules to deny writes by unauthenticated users. (Test: Sign out/in on a clean install and attempt a Firestore write from the client to verify rules block unauthenticated access.)
- [x] Scaffold core navigation: bottom tabs (Home, Account, Discover placeholder). (Test: Navigate across all three tabs after hot restart to ensure state and theme persist without crashes.)
- [x] Implement ThemeProvider, app theme switch, and persist preference locally. (Test: Toggle dark mode, kill the app, relaunch, and ensure the previous theme returns while navigation/auth still behave.)
- [x] Wire Firebase initialization with `firebase_core` and confirm anonymous login flow. (Test: Observe app logs for successful anonymous UID issuance on cold start and confirm `AuthGate` routes to the main tabs.)
- [x] Define core terminology (Pulse) and update copywriting guidelines so UI messaging stays consistent. (Test: Run `rg "check-in"` over lib/docs to verify only legacy references remain and review `copywriting.txt` for coverage.)

### Phase 1 – Core Pulse Experience
- [x] Design Firestore collections (`users`, `venues`, `pulses`) aligned with firebase.txt spec. (Test: Execute unit tests instantiating the new model classes and ensure Firestore converters serialize/deserialize sample payloads correctly.)
- [x] Build location permission request & geolocation service (using `geolocator` or similar). (Test: Launch on a fresh simulator, grant/deny permissions, and confirm the location state updates without breaking anonymous auth or theme persistence.)
- [x] Implement venue search + nearby list using sample data; integrate Firestore geohash queries later. (Test: Seed mock venues, search for a keyword, and verify results refresh while navigation tabs and location service keep functioning.)
- [x] Wire up MapLibre GL with OpenStreetMap tiles for the discovery map and test marker rendering. (Test: Render the Discover map after location permission is granted and ensure MapLibre tiles plus markers appear with no dropped frames.)
- [x] Validate tile usage limits and configure style/theme files for MapLibre to match Pulse branding. (Test: Inspect MapLibre network calls during a 10-minute session to confirm tile limits aren't exceeded and styles match light/dark theme toggles.)
- [ ] Integrate Foursquare Places API (free tier) for venue metadata during prototyping. (Test: Call the API via staging key, cache the response, and compare venue details with Firestore docs to ensure consistency and rate-limit compliance.)
- [ ] Stub abstraction layer so alternate POI providers can be swapped without core refactor. (Test: Swap the provider implementation in tests to a mock HERE client and verify the UI still lists venues without code changes elsewhere.)
- [ ] Create Pulse composer (select venue, mood, caption, optional photo upload to Storage). (Test: Submit a Pulse with photo on both Wi-Fi and offline to ensure drafts handle failures and the mirrored user collection writes correctly.)
- [ ] Add lightweight privacy controls to the composer (public / friends / private) with client validation. (Test: Create Pulses under each visibility level and confirm the feed respects the filter while Firestore rules block unauthorized readers.)
- [ ] Write Cloud Function or serverless callable to mirror Pulses into `users/{userId}/pulses` and update counters. (Test: Trigger the function locally with emulators and verify both global and user collections receive the new document with updated stats.)
- [ ] Enforce security rules for anonymous users (read-only public venues, own Pulses only). (Test: Run Firestore emulator tests that attempt cross-user writes to ensure rules reject them while allowing public reads.)
- [ ] Basic activity feed showing recent public Pulses; apply visibility filtering client-side for now. (Test: Log in with two accounts, post Pulses under different visibilities, and confirm the feed only shows public entries to anonymous users.)

### Phase 2 – Social Growth Loop
- [ ] Migrate authentication from anonymous to email/password; retain anonymous sessions with link flow. (Test: Link an existing anonymous session to email, sign out/in, and confirm the user retains their Pulses and tokens.)
- [ ] Update security rules to require verified auth for write operations; restrict anonymous users to read-only mode. (Test: Run emulator rule tests ensuring anonymous users receive PERMISSION_DENIED on writes while linked accounts succeed.)
- [ ] Build profile screen editing (displayName, avatar upload) with Storage rules enforcement. (Test: Upload a new avatar, reload the app, and confirm Storage metadata enforces ownership and the UI shows the updated image.)
- [ ] Implement friend requests using `friendships` collection (send, accept, block flows). (Test: Create request sequences between two test users and verify rule tests prevent unsolicited acceptances or blocks.)
- [ ] Launch collaborative planning boards (shared checklists, polls) tied to venues or time slots. (Test: Have multiple friends edit the same board simultaneously and ensure optimistic updates sync without conflicts.)
- [ ] Highlight meaningful contributions (tips, photos, accessibility info) within venue detail views and feeds. (Test: Submit diverse tips and verify only high-signal contributions surface after feed refresh while navigation remains responsive.)
- [ ] Introduce push notification registration via FCM token storage and targeted friend activity notifications. (Test: Register two devices, trigger a friend Pulse, and confirm only opted-in friends receive the push with correct deep link.)
- [ ] Add simple in-app notifications (Firestore `notifications` collection) for friend requests, accepted invites, and collaborative updates. (Test: Simulate friend invites and confirm notification badges update, clearing properly after viewing.)
- [ ] Prototype creator/venue tooling (featured guides, partner badges) to seed premium content. (Test: Create a partner guide via admin tools and ensure it appears in Discover without exposing controls to regular users.)

### Phase 3 – Intelligent & Adaptive Experience
- [ ] Integrate live Firestore venue data with geospatial indexing (GeoFireX or custom geohash queries). (Test: Run geospatial queries at varying radii and verify results stay within expected bounds and update after moving location.)
- [ ] Add rating/tips subsystem under venue subcollections with write validation and quality scoring. (Test: Submit ratings from multiple accounts and ensure averages recompute without allowing duplicate submissions.)
- [ ] Upgrade Foursquare usage to production plan or cache data via Cloud Functions to stay within limits. (Test: Replay a day's worth of venue lookups and confirm cached responses reduce API calls under quota.)
- [ ] Launch badge system: define `badges` documents and Cloud Functions for progress tracking. (Test: Award a badge via automated function and assert the user sees it in their profile while duplicates are prevented.)
- [ ] Personalize discovery feeds using context (time of day, weather, past behavior) and privacy preferences. (Test: Switch contexts (morning/night) on test accounts and ensure recommended Pulses change while respecting privacy flags.)
- [ ] Measure success beyond Pulse volume—track recommendation follow-through metrics via analytics pipeline. (Test: Review the analytics dashboard after simulated sessions to confirm recommendation_click events correlate with venue visits.)
- [ ] Enhance activity feed with badges, friend joins, and trending venues; optimize queries via composite indexes. (Test: Run load tests fetching feeds for 1k users and verify indexes prevent Firestore query failures.)
- [ ] Implement moderation/reporting callable functions and admin tooling (custom claims). (Test: Invoke the callable with and without admin claims to ensure only moderators can change Pulse visibility.)
- [ ] Switch default privacy to friends-only and provide granular privacy settings UI. (Test: Create new accounts and confirm their default Pulse visibility is friends-only while existing users retain previous choices.)
- [ ] Prototype an AI assistant that suggests meetups or itineraries using current location + friend availability. (Test: Feed mock schedules into the assistant and ensure suggested itineraries respect location consent and friend statuses.)
- [ ] Optimize Storage usage: generate thumbnails via Cloud Functions and lazy load media. (Test: Upload large media files and verify thumbnails appear while original downloads defer until tapped, reducing bandwidth.)

### Phase 4 – Scaling & Polish
- [ ] Introduce email verification and optional OAuth providers (Apple/Google) for better retention. (Test: Register via Google and Email, verify addresses, and ensure existing anonymous Pulses remain linked after upgrade.)
- [ ] Build group threads and direct messaging using `messages` collection and presence indicators. (Test: Simulate three-user chats and confirm presence indicators update in real time without leaking data to outsiders.)
- [ ] Configure scheduled Cloud Functions for trending venue computations and stale activity cleanup (Firestore TTL). (Test: Run the scheduler in emulator mode to ensure old Pulses expire and trending scores update without failures.)
- [ ] Instrument analytics (Firebase Analytics/BigQuery) for engagement and growth dashboards. (Test: Export sample analytics events to BigQuery and verify dashboards refresh with accurate Pulse engagement metrics.)
- [ ] Load-test Firestore queries and refine indexes; review costs with budget alerts. (Test: Execute k6 or Firestore load tests exceeding baseline traffic and monitor GCP budget alerts firing correctly.)
- [ ] Harden security rules with simulator tests and add regression test suite in CI. (Test: Run `firebase emulators:exec` in CI and confirm all rule tests pass before allowing deployments.)
- [ ] Prepare App Store & Play Store deployment assets, privacy policy, and crash reporting (Crashlytics). (Test: Build release candidates, upload to TestFlight/Play Console, and verify Crashlytics captures test crashes without missing metadata.)
- [ ] Establish business/creator onboarding workflows and partnerships programs. (Test: Walk through the onboarding form end-to-end with a pilot partner and confirm approvals unlock creator-only tooling.)
